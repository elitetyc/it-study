**怎么防止缓存击穿的问题？**

```
注意缓存穿透和缓存击穿的区别！！！！
缓存穿透是指：数据不存在，导致数据全部打到数据库
缓存击穿是指，数据的访问量很大，但是数据在某一刻过期了，对这一条数据的大量访问请求都打到了数据库，例如微博一个热点新闻，该新闻设置了过期时间2小时，
当2小时到了，这个热点新闻失效的一瞬间，还有成千上万的请求要访问这个数据，发现缓存过期了，请求直接打到数据库了，导致数据库压力激增

解决办法就是设置数据永不过期
```

[缓存雪崩，穿透，击穿](https://github.com/elitetyc/it-study/blob/main/%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E7%A9%BF%E9%80%8F%EF%BC%8C%E5%87%BB%E7%A9%BF.md)

**布隆过滤器的原理是什么？它的优点是什么？缺陷是什么？**

```
布隆过滤器可以用来判断一个数据是否存在，但是可能存在误判
原理：使用大量的比特位用来，记录数据是否存在，存在比特位置为1，不存在为0，同时针对一条数据进行多次hash，将值对应的比特位置为1，这样可以减少碰撞，
结果更精确一些
优点：占用空间少，判断数据快
缺点：可能存在误判，但是布隆过滤器说数据不存在，那么数据一定不存在，如果说数据存在，那么数据不一定存在于数据库，并且数据删除，不能更新到布隆过滤器

实战：例如我们要判断id为100的数据在不在数据库中，可以使用布隆过滤器
1.项目启动，将数据库中所有的id查询出来，每个id进行三种hash算法得出三个下标
2.将三个下标对应的比特位置为1(可能其他id的hash值也相同，就出现了hash冲突，这也就是为什么会误判)
3.数据处理完成后，查询id为100的数据，先将id也进行三种hash运算，算出三个下标
4.如果三个下标对应的比特位值都为1，说明数据可能存在于数据库
5.如果布隆过滤器说数据不存在，直接返回，如果说数据存在，查询数据库，判断数据存不存在，这样就在查询数据库之前加了一次过滤，对于一定不存在于数据库的值直接不需要访问数据库了
```

[布隆过滤器你需要知道的](https://mp.weixin.qq.com/s/BdwZViiAqnFhCde4ZsxwPg)

**Java为什么被称为平台无关性语言？**

```
因为每个平台的jvm实现是不一样的，jvm层面对外屏蔽了平台之间的差异，java虚拟机运行字节码，会将字节码执行为对应平台的命令
所以“一次编写，处处运行”
```

**了解JVM吗？为什么需要垃圾回收呢？**

```
java虚拟机将内存分为堆，栈，方法区(元空间),程序计数器，本地方法栈，除了程序计数器，都需要进行垃圾回收
为什么需要垃圾回收：
之前有看到一个段子(搞笑)说：在食堂吃完饭自己捡盘子的是写c，c++的，吃完饭直接走的是写java，因为知道有人收盘子
因为java程序运行会不断的伴随新对象的创建，如果只是一味的创建，对于不再使用的对象不进行回收的话，终有一天内存会占满~
```

**常用的垃圾回收器有哪些？**

```
serial（英文连续）是最基本垃圾收集器，使用复制算法，曾经是JDK1.3.1 之前新生代唯一的垃圾
收集器。Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工
作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。

ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃
圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也
要暂停所有其他的工作线程。

Serial Old 是 Serial 垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，
这个收集器也主要是运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器。

Parallel Old 收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在 JDK1.6
才开始提供

Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾
回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。

Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器，G1 收
集器两个最突出的改进是：
1. 基于标记-整理算法，不产生内存碎片。
2. 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。
```

**详细介绍下CMS？**

```
cms垃圾收集器：采用标记-清除算法，优点就是停顿时间小
初始标记：只标记与GCRoots直接关联的对象和新生代指向老年代的对象(速度很快)
并发标记：跟用户线程一起运行，将上一步标记的对象进行遍历，因为这里还要标记与GCRoots间接关联的对象了
并发预处理：因为并发标记阶段是与用户线程一起运行的，这个阶段可能出现对象变化(例如新生代对象晋升到老年代)，预处理减少下一步STW的时间
重新标记：STW最终标记
并发清除：跟用户线程一起运行，直接清除掉无用的对象
```

[详解cms垃圾收集器](https://blog.csdn.net/qq_45207631/article/details/119868686)

**什么情况下老年代会发生GC？**

```
1.进行minorGC时会判断如果 老年代对象连续空间<每次新生代转到老年代的对象的平均值, 说明这次新生代GC后，可能转为老年代的对象会比老年代可用对象大，触发majorGC
2.如果进行了minorGC，现在需要确定需要晋升到老年代的对象,超过了老年代可用大小，触发majorGC
3.老年代空间使用率超过了指定值(可配置)92%,触发majorGC
```

**String、StringBuilder、StringBuffer有什么区别？**

```
String：不可变字符串，更改值是是新创建字符串常量修改引用，适用于少量的字符串操作的情况

StringBuffer：适用于多线程下在字符缓冲区进行大量操作的情况

StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况
```

[String、StringBuilder、StringBuffer有什么区别](https://www.jianshu.com/p/1e6041bd5af2)

**HashMap是线程安全的吗？为什么呢？**

```
因为hashmap中没有使用同步锁相关的内容，并且在1.8之前采用头插法，多线程下会发生死循环，
虽然在1.8开始使用了尾插法，不会再发生死循环，但是多线程下，还是会出现put覆盖等一系列问题
```

[为什么说HashMap是线程不安全的](https://blog.csdn.net/m0_49622667/article/details/124392711)

**HashMap在遇到key冲突的时候是怎么处理的呢？**

```
key的hash计算公式(高16位与低16取异或):(h = key.hashCode()) ^ (h >>> 16)
hash值对应存放在数组的下标计算公式为(其中table一定为2的n次方): hash & (length-1)
当不同的key计算出的下标是相同时：
1.找到数组中对应下标存放的值
2.发现数据不为空，说明发生了hash冲突，如果节点类型是树节点，就将新的key存放到树，如果节点是普通节点(链表节点)，遍历到链表的最后一个，插入新数据
```

**HashMap底层为什么要用红黑树呢？为什么不用平衡二叉树？**

```
AVL 树是严格的平衡树，上述的最短路径与最长路径的差不能超过 1，AVL 允许的差值小；在进行大量插入和删除操作时，会频繁地进行平衡调整，严重降低效率；
红黑树虽然不是严格的平衡树，但是其依旧是平衡树；查找效率是 O(logn)；
AVL也是 O(logn)；
红黑树舍去了严格的平衡，使其插入，删除，查找的效率稳定在 O(logn)
反观 AVL 树，查找没问题 O(logn)，但是为了保证高度平衡，动态插入和删除的代价也随之增加，综合效率肯定达不到 O(logn)
所以在进行大量插入，删除操作时，红黑树更优一些
```

**HashMap不是线程安全的，如果要保证线程安全怎么办呢？可以用什么？**

```
1.可以使用HashTable:内部操作方法都添加了synchronized关键字，实现线程安全
2.使用Collections.synchronizedMap(HashMap)：内部类SynchronizedMap，里面有一个锁对象mutex就是SynchronizedMap自己，
里面操作方法都使用了synchronized(mutex){},使map的操作都是线程安全
3.使用ConcurrentHashMap：1.7使用分段锁：ReentrantLock+Segment+HashEntry  1.8使用synchronized+CAS+HashEntry+红黑树
（因为实际操作中，出现资源竞争的情况很少，同时资源占用的时间也很短，1.7-1.8的转变，更加缩小了锁的力度，同时使用cas，减少了上下文切换，提高了效率）

```


**tcp和udp有什么区别？分别应用于哪些场景？**

```
TCP是可靠的传输，速度慢，建立连接断开连接需要三次握手四次挥手，例如文件传输
UDP不可靠的传输，但是速度快，但是可能会丢包，常用于直播，实时通话等
```
[TCP和UDP的区别](https://blog.csdn.net/ymb615ymb/article/details/123449588)



#### 更多IT资料关注下方公众号，电子书，面试手册，八股文，实战项目应有尽有！

<img src="../img/qrcode_for_gh_ab887c285d36_344.jpg" alt="qrcode_for_gh_ab887c285d36_344" style="zoom:50%;" />

<img src="../img/image-20220607210605564.png" alt="image-20220607210605564" style="zoom:50%;" />