
**项目用到redis redis过期数据删除的机制 删除的策略**

```
使用redis存放用户token，一些不常变化的数据，比如某个用户的菜单权限信息等
redis数据过期删除机制：
定期删除：每隔指定时间就随机找出W(默认100个)个设置了过期时间的key，假设有N个key过期了，删除这些过期的key，如果 (N/M)*100% > P(默认值25%)，就再次轮训删除，
直到过期key的百分比<=P（默认值25%），这里的W和P都是可以配置的

当新数据进入redis，redis空间不足，有以下删除策略：
针对带过期时间的数据：
volatile-lru：挑选最近最少使用的数据淘汰
volatile-lfu：挑选最近使用次数最少的数据淘汰
volatile-ttl：挑选将要过期的数据进行淘汰
volatile-random：任意选择数据进行淘汰
针对所有数据：
allkeys-lru：挑选最近最少使用的数据进行淘汰
allkeys-lfu：挑选最近使用次数最少的数据淘汰
allkeys-random：任意选择数据进行淘汰
no-enviction：禁止驱逐数据，会引发错误OOM
```

**实际项目中用到了redis哪些数据结构 用list做了什么**

```
用到了String，List，Set，Zset，Hash
String:用来存放用户token信息，每次用户登陆之后会存放token到redis，并且设置过期时间，每次接口访问会先访问redis查询请求携带的token是否存在与redis，
不存在时需要重新登陆
List：用来做一个简易的消息队列，或者文章详情中右侧最近文章列表，这种变动不大的数据
Set：不包含重复元素的无序集合，可以用来做类似微博的共同关注，或者可能认识的功能，他可以列出两个集合的交集，或者差集
Zset：带权重的不包含重复元素的集合，会自动根据权重进行排序，可以用来做网站浏览量排行榜的功能
Hash: 相比较于直接将整个数据存放到String，如果对象的某个字段修改了，需要整条数据进行修改，如果使用hash来，只需要修改指定的某个字段值就好了
```

[一文搞懂redis](https://mp.weixin.qq.com/s/7ct-mvSIaT3o4-tsMaKRWA)

**kafka 如何保证消费者不会重复消费数据**

```
保证幂等性，每个消息给一个唯一的id，并且创建一个消息表，
生产者创建的消息，插入消息表时先查询，这个唯一id如果有记录，就说明消息已经发送了，不要重复发送，如果唯一id数据不存在，新增消息，标记消息状态为待处理，
消费者，消息处理时，根据唯一id查询数据，如果数据状态为待处理，开始处理数据，最后将状态设置为已消费，如果状态为已消费，说明已经被别的线程消费了，不做别的处理
```

**offset提交方式**

```
自动提交，手动提交
```

**kafka有没有什么确认机制保证消息一定写入kafka集群当中**

```
spring.kafka.producer.acks:
配置为0时：只要消息通过网络发送出去就认为发送成功了，不管集群是否接收到消息
配置为1时：保证leader副本接收到消息，就认为是成功了
配置为-1时：保证所有副本都接收到了消息，才认为是成功了(等待的时间长一些，但是可以确保消息在leader和flower副本中都存在)
```

**哈希表的作用 哈希表使用的数据结构 哈希内部解决哈希冲突的方式有哪几种**

```
哈希表使用较低的时间复杂度，获取数据
使用的数据结构是：数组+链表+红黑树

解决hash冲突的方式：链地址法，再哈希
```

**多线程环境下为什么要引入同步的机制**

```
因为多线程下，如果不使用同步机制，对于同一个资源变量，会被拷贝副本到自己的线程，对于这一个资源变量的修改，对其他线程不可见，可能会出现数据丢失的情况
```

**java内部有哪些同步的机制 回答 synchronized 和 ReentrantLock 问 这两种锁有哪些区别**

```
针对某个变量可以使用volatile关键字保证可见性
synchronized：是java的关键字，是jvm层面的实现，非公平锁
ReentrantLock：使用AQS，是java代码层面的实现，可以实现公平锁和非公平锁
```

**多线程什么场景下会发生死锁**

```
例如有两个事务，事务A操作数据的顺序是12，事务B操作数据的顺序是21
这时候，假设事务A操作了数据1，事务B操作了数据2，
下一步事务A需要操作数据2了，但是数据2被事务2修改了，被锁住，那么事务A就需要进行等待，同时，事务B需要操作数据1了，但是数据1被事务A修改了，
数据1被锁住了，则事务B也需要等待，这样两个事务两个线程互相等待对方，结果就出现了死锁

解决方法：保证线程对资源的访问顺序，例如在这个操作里面，就可以根据数据id排序一下
```

**有什么具体的办法可以避免死锁**

```
（1）保持加锁顺序：当多个线程都需要加相同的几个锁的时候（例如上述情况一的死锁），按照不同的顺序枷锁那么就可能导致死锁产生，所以我们如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。

（2）获取锁添加时限：上述死锁代码情况二就是因为出现了获取锁失败无限等待的情况，如果我们在获取锁的时候进行限时等待，例如wait(1000)或者使用ReentrantLock的tryLock(1,TimeUntil.SECONDS)这样在指定时间内获取锁失败就不等待；

（3）进行死锁检测：我们可以通过一些手段检查代码并预防其出现死锁
```

**Http的请求报文和响应报文各有哪几部分组成**

```
请求报文包含3部分。
（1）请求行，包含请求方法、URI、HTTP版本信息。
（2）请求首部字段。
（3）请求内容实体。
响应报文包含3部分。
（1）状态行，包含HTTP版本、状态码、状态码的原因短语。
（2）响应首部字段。
（3）响应内容实体。
```

**Http 协议和TCP协议的关系是什么**

```
TCP协议是传输层协议，主要解决数据如何在网络中传输

HTTP是应用层协议，主要解决如何包装数据。
```


#### 更多IT资料关注下方公众号，电子书，面试手册，八股文，实战项目应有尽有！

<img src="../img/qrcode_for_gh_ab887c285d36_344.jpg" alt="qrcode_for_gh_ab887c285d36_344" style="zoom:50%;" />

<img src="../img/image-20220607210605564.png" alt="image-20220607210605564" style="zoom:50%;" />