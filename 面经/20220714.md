#### 1.分布式锁有了解吗

```
在单体单点项目中，我们如果要限制某一个方法某一时刻只能一个线程进入，通常做法就是加锁，synchronized或者ReentrantLock等，现在项目访问量大起来了，
一个服务扛不住了，又多部署了几个相同的项目，并进行了负载均衡，这时候因为相当于这几个不同的项目处于不同的进程，甚至处于不同的机器上面，原来的锁方式就不适用了
(也就是说同一个方法逻辑，同一时刻可能有多个线程都在执行)，这样数据最终落库可能与我们的期望值有差距，所以我们就需要使用分布式锁，我们的最终目标就是保证只有一把锁，
如果锁被别人抢占了，抢占失败进行重试或者失败，分布式锁的实现方式有很多种，例如直接使用关系型数据库，redis，zookeeper等等，也就是只要找一个业务代码能访问到的某一个唯一的资源
```

#### 2.数据库底层有了解吗

```
mysql了解的有存储引擎(innodb,myisam,csv,memory等)，索引(使用b+树，聚餐索引，非聚餐索引等)
```

#### 3.讲下聚簇索引

```
聚餐索引，主键索引(针对于innodb引擎)：索引即数据，每个表只能包含一个聚簇索引，整条数据也存放在叶子结点
非聚簇索引：一张表可以包含多个非聚簇索引，叶子结点存放的是对应的索引列和主键值(一般通过非聚簇索引查询数据，先找到主键值，再回表通过主键值去聚簇索引查询具体的数据内容，注意覆盖索引不需要回表)
```

#### 4.怎么解决慢查询

```
查询慢查询日志相关的信息：SHOW VARIABLES LIKE '%slow_query_log%'
查询结果：slow_query_log(是否开启了慢查询日志)	    OFF
        slow_query_log_file(慢查询日志存放的位置)	/var/lib/mysql/8c88e1a85ede-slow.log
        
开启慢查询日志：SET GLOBAL slow_query_log = 1

查询慢查询的阈值，也就是超过这个阈值的sql才会被记录(默认是10秒)：SHOW VARIABLES LIKE '%long_query_time%'

解决慢查询：创建索引，expain分析sql，大表拆分，limit查询优化(offset过大的话，会扫描+回表)，
```

#### 5.索引底层

```
索引底层使用B+树，B+树只在叶子结点存储数据，索引千万的数据树高3层就可以，树高4层可以索引上亿的数据
```

#### 6.b+树跟b树有啥区别
```
1. B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。

2. B+树中所有叶子节点都是通过指针连接在一起，而B树不会。

3. B+树的查询速度更快
```

#### 7.你说b+树能范围查询，怎么实现的
```
例如我们要查询id>10 AND  id<100的数据，先根据id查询>10的第一条数据，这条数据位于b+树的叶子结点，由于b+树的叶子结点也是按照从小到大排序的，并且叶子结点之间有指针进行连接，
直接递归往后进行遍历，直到遍历到id>=100的数据。前面的所有数据就是我们要查找的这个范围中的数据
```

#### 8.b+树的高度怎么计算

```
叶子结点到根节点的距离，就是树的高度，一般树高3就可以索引千万数据，树高4可以索引上亿的数据
并且根节点常驻内存，当树高3的时候，实际再进行2次磁盘读就可以找到数据，当树高4，实际在进行1次磁盘读就可以找到数据

mysql的innodb默认页面大小为16k，假设我们的主键类型为bitint(8字节)，结点还包含下一个节点的指针6字节，即一个非叶子结点的大小为14字节，
即1页可以存放16*1000/14约等于1000，第二层能存放的数据为：1000*1000=100 0000
第三层如果是叶子结点(直接存放数据)，假设数据大小为1K，每页可以存16个数据，所以第三层能存放的数据为：16*1000*1000=1600 0000(1600w)
第四层如果才是叶子结点,能存放的数据为，16*1000*1000*1000 = 160 0000 0000(160亿数据)

```

#### 9.b树和b+树的叶子节点和非叶子节点都存什么

```
b树的叶子结点和非叶子结点都直接存储数据
b+树的非叶子结点存放单个索引值，叶子结点存放详细的数据(主键索引存放的是主键+所有字段，非主键索引存放的是索引值+主键值，因为需要回表查数据)，
```

#### 10.mysql最多能存多少数据

```
据D.V.B 团队以及Cmshelp 团队做CMS 系统评测时的结果来看，MySQL单表大约在2千万条记录（4G）下能够良好运行，经过数据库的优化后5千万条记录（10G）下运行良好
一般数据超过千万就要考虑分库分表了
```

#### 11.Mysql默认的事务隔离级别是什么，有什么缺点

```
默认隔离级别为可重复读，采用mvcc方式来实现(数据版本链+readview)，会出现幻读
```

#### 12.什么是幻读
```
幻读就是事务A查询id>1的数据查出来一条，然后事务B插入了一条数据 id =2 ,然后事务B再进行一次id>1的查询，查出来了2条，好像出现了幻觉一样
```

#### 13.怎么解决幻读

```
隔离界别设置为串行
```

#### 14.Mysql的log有哪些，分别用来解决什么问题

```
binlog:二进制日志，存放mysql中的增删改操作的sql，时间等
redolog:重做日志,防止事务提交后，数据只是提交到内存，还没有刷新到磁盘，用来做数据恢复
undolog:回滚日志, 事务回滚使用，版本链，为读已提交和可重复读隔离级别使用(MVCC)
```

#### 15.怎么看mysql有没有执行索引
```
explain 某个sql 进行执行 ，当返回值中的key不为null时说明使用到了索引

```

#### 16.explain的时候最关心哪些字段，分别是什么含义

```
id：是select 的标识符，表示select 语句的执行顺序；如果该select语句有嵌套查询，则explain会有多行结果返回，也就会有多个id，id的数字越大表示该select子句越先执行；如果数字相同，则按从上到下的顺序执行；

select_type: select_type会根据不同的SQL语句返回不同的结果；它有以下返回结果：

           SIMPLE:表示不需要union操作或者不包含子查询的简单select语句，如果有连接查询，外层的查询为simple，且只有一个；

           primary:一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary,且只有一个；

           union:union连接的多个select查询，第一个查询是derived派生表，除了第一个表外，第二个以后的表的select_type都是union;

           dependent union:与union一样，出现在union或union all中；取决于外部查询的结果；

           union result:包含union的结果集，在union和union all语句中，因为他不需要参与查询，结果中的id字段为null;

           subquery: 除了from子句中包含的子查询外，其他地方出现的子查询都可能是subquery，说白了就是子查询；

           dependent subquery:与dependent union类似，表示这个subquery的查询要受到外部表查询的影响 ；

           derived：表示派生表；

table: 显示查询的时候涉及的表，如果是临时表，则显示临时表，临时表用<>表示；

type: 表示SQL语句的性能从好到差：system,const,eq_ref,ref,fulltext,ref_or_null,unique_subquery,index_subquery,range,index_merge,index,all;

           如果显示的是all，则表示该SQL语句进行的是全表扫描，没有使用index，那该SQL语句的性能是最差的，除了all之外，其它的type都可以使用到索引；

           system: 表示表中只有一行数据或者是空表，且只能用于myisam和memery表；

           const：表示使用唯一索引或者主键；

           eq_ref: 表示驱动表只返回一行数据，且这一行数据是第二个表的主键或者唯一索引，且必须为not null；唯一索引和主键是多列时，只有所有的列都用作比较时，才会出现eq_ref;

           fulltext: 全文索引检索，全文索引的优先级很高，如果全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引；

           index：索引全表扫描，把索引从头到尾扫一遍；

           all：     表示全表扫描数据文件，再从server层进行过滤返回符合要求的记录；

possible_keys: 查询可能使用到的索引都会在这里列出来

key：查询真正使用到的索引；

key_len: 用于处理查询的索引长度，如果是单列索引，那就是整个索引的长度；如果是多个索引，只会列出使用到了多少个列的索引，没有使用到的列不会计算进去；

ref： 如果使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里显示为func;

rows: 执行计划估算的扫描行数，不是精确值；

extra: 返回的值

       distinct :  表示查询的时候使用了distinct关键字；

       no tables used: 不带from子句或者 from dual查询；

       using filesort : 排序时无法使用到索引时，常见于order by 和 group by 语句中；

       using index: 查询时不需要回表中查询，直接通过索引就可以获取查询的数据；

       using intersect: 表示使用and 的各个索引的条件时，该信息表示是从处理结果获取交集；

       using where：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过渡
```

#### 17.讲下hashmap底层结构，put操作怎么找到位置的，&运算等价于什么运算？为什么不是线程安全的，1.8是头插还是尾插？怎么保证线程安全
```
底层结构是：数组+链表+红黑树(大于8个链表转为红黑树，少于6个红黑树转为链表)
put操作：先获取key的hashCode,hashCode高16位与低16位进行异或操作hash=(h = key.hashCode()) ^ (h >>> 16)，然后通过 index=hash&(length-1),当这个length的值
是2的n次方时，&等价与%取余运算，之所以使用&时因为位运算效率高
为什么不是线程安全的:因为map的操作没有加锁，在多线程环境下，1.7之前采用头插会产生死循环，1.8开始会出现存放那个的值覆盖的情况
保证线程安全：使用Collections.synchronizedMap将hashmap转换成一个线程安全的map（实际上就是在对hashmap存取操作的时候加锁）,或者使用ConcurrentHashMap

```

#### 18.concurrenthashmap底层，1.7怎么扩容的，1.8怎么保证线程安全

```
1.7采用 segment分段锁机制，segment继承自ReentrantLock，segemnt里面又是数组+链表的结构
1.8取消segment分段锁，因为实际上的锁竞争很少，所以为了再减小锁的粒度，直接使用cas和synchronized来实现，当计算出的下标冲突时，锁住的是数组中的对应下标的值
```


#### 19.Synchronized怎么实现的

```
内存屏障，moniterenter 代码 moniterexit，在这两个命令之间的代码，每次只能有一个线程执行
```

#### 20.作用于方法时锁的是什么，静态方法锁的是什么，怎么实现可重入的
```
有一个锁计数器，线程A获取到锁，这个锁计数器就+1，如过线程A中递归调用了，这个方法，再次进入时，发现获取到锁的线程就是自己，这个锁计数器再+1，退出一次，
这个锁计数器-1，当锁计数器为0时，锁就释放了
```

#### 21.CAS是什么，有什么缺点
```
比较并交换，三个参数(要修改的地址,期望值,新的值),当对应地址的值是期望值的时候，将值修改为新的值，否则失败
可能出现的问题是ABA问题
```

#### 22.ABA怎么发生的，怎么解决ABA问题
```
使用cas时，例如线程A 先获取数据为10，然后线程B也获取数据为10,然后提交数据为20，然后线程C获取数据为20，然后提交数据为10，
好了，这时候线程A处理完了，需要将数据修改为30，cas发现旧数据还是10，就修改为30，虽然数据是一样，但中间出现了一些其他的操作对线程A并不可见，最后数据也修改成功了，
最后有一个狸猫换太子的感觉(你的老婆跟别人睡了一晚，回到家还是你的老婆吗？)

解决ABA问题:使用AtomicStampReference,这个类会另外存放一个版本号，更新操作之后，版本号也要更新，这样，上面的例子，线程A获取的数据就是10,版本号1,
经过两次修改，数据成为了10,版本号3，线程A再进行数据更新时，版本号对不上，所以修改失败
```

#### 23.ReetrantLock有用过吗，怎么实现重入的
```
原理就是AQS，抽象同步队列，里面有一个volatile类型的int变量，state用，当一个线程获取到锁时，这个值+1，这个线程再想获取这个锁，发现锁当前已经被这个线程获取了，那么state+1,
释放一次锁，state-1,其他线程来看这个state!=0就无法获取到锁，进入到等待队列

```


#### 24.Volatile解决了什么问题，一般用在哪里

```
保证了可见性，禁止指令重排序

一般用在多个线程要共同访问同一个变量的时候，这个共同变量就需要使用volatile关键字保证可见性，
因为不加关键字，默认每个线程会从主存拷贝一个副本到自己的工作线程，对这个变量进行操作，合适的时机再刷新会主存，多线程环境下就会出现期望值与最终值不符合的情况，
使用volatile关键字，线程在使用这个变量的时候都是去主存获取，不会再拷贝副本
```

#### 25. Jdk1.6对锁做了哪些优化
```
锁升级，
无锁->偏向锁->轻量级锁->重量级锁
```

#### 26. Spring的AOP的实现方式
```
动态代理，jdk动态代理，cglib动态代理
jdk动态代理主要用于实现了接口的对象，因为代理类默认需要继承一个Proxy类，java单继承，多实现，所以只能针对接口进行代理，动态生成类
cglib动态代理：动态修改字节码，所以无论要代理的对象是接口还是普通类都可以进行代理
```


